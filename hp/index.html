<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>3D PARTY ENGINE</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'VT323', monospace; user-select: none; }
        
        #ui-layer { position: absolute; top:0; left:0; width: 100%; height: 100%; pointer-events: none; }
        
        /* LOADING SCREEN */
        #loader { 
            position: absolute; top:0; left:0; width:100%; height:100%; background: #111; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center; color: #0f0;
        }
        .load-spin { width: 50px; height: 50px; border: 5px solid #333; border-top: 5px solid #0f0; border-radius: 50%; animation: spin 1s infinite linear; }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* HUD */
        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; 
            transform: translate(-50%, -50%); mix-blend-mode: difference; 
        }
        #crosshair::before { content:''; position: absolute; top: 9px; left: 0; width: 20px; height: 2px; background: #fff; }
        #crosshair::after { content:''; position: absolute; top: 0; left: 9px; width: 2px; height: 20px; background: #fff; }

        #card {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9); border: 4px solid #fff; padding: 40px;
            text-align: center; border-radius: 10px; pointer-events: auto; min-width: 300px;
        }
        #card-msg { font-size: 40px; color: #ff0; text-shadow: 2px 2px #f00; margin-bottom: 20px; white-space: pre-wrap; line-height: 1.2; }
        .btn { 
            background: #fff; color: #000; border: none; padding: 10px 20px; font-size: 24px; 
            cursor: pointer; font-family: 'VT323'; text-transform: uppercase; 
        }
        .btn:hover { background: #ff0; }

        #stats { position: absolute; bottom: 20px; left: 20px; font-size: 30px; color: white; text-shadow: 2px 2px 0 #000; }
        
        /* Hearts animation in CSS (optional fallback) */
        @keyframes floatHeart { 0% { transform: translateY(0); opacity:1; } 100% { transform: translateY(-50px); opacity:0; } }
    </style>
</head>
<body>

<div id="loader">
    <div class="load-spin"></div>
    <h2 style="margin-top:20px">LOADING WORLD...</h2>
    <p style="color:#666; font-size: 14px;">(Click to Enable Audio)</p>
</div>

<div id="ui-layer">
    <div id="crosshair"></div>
    <div id="stats">SCORE: <span id="score">0</span></div>
    <div id="card">
        <div id="card-msg">...</div>
        <button class="btn" onclick="closeCard()">AWESOME!</button>
    </div>
</div>

<script>
    // --- GLOBAL STATE ---
    let config = { 
        skyText: "LOADING...", 
        balloons: ["TEST"], 
        mode: 'google', 
        googleSettings: { lang: 'en', pitch: 1, rate: 1 },
        audioMap: {} 
    };

    const urlParams = new URLSearchParams(window.location.search);
    const id = urlParams.get('id');

    // --- HEART TEXTURE ---
    const heartCanvas = document.createElement('canvas'); heartCanvas.width = 32; heartCanvas.height = 32;
    const hCtx = heartCanvas.getContext('2d');
    hCtx.fillStyle = "red"; hCtx.font = "24px serif"; hCtx.fillText("❤️", 4, 24);
    const heartTex = new THREE.CanvasTexture(heartCanvas);

    // --- INIT ---
    async function start() {
        if(id) {
            try {
                const res = await fetch(`https://kgbgamelab.github.io/texts/data/${id}.json?nocache=${Date.now()}`);
                if(res.ok) {
                    const json = await res.json();
                    config = json.data || json; 
                }
            } catch(e) { console.error(e); }
        }
        document.getElementById('loader').style.display = 'none';
        init3D();
    }

    // --- AUDIO SYSTEM ---
    function speak(text) {
        if(config.audioMap && config.audioMap[text]) {
            const snd = new Audio(config.audioMap[text]);
            snd.play().catch(e => console.log("Audio block:", e));
            return;
        }
        if(config.mode === 'google') {
            const lang = config.googleSettings?.lang || 'en';
            const url = `https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&tl=${lang}&q=${encodeURIComponent(text)}`;
            const audio = new Audio(url);
            if(config.googleSettings?.rate) audio.playbackRate = config.googleSettings.rate;
            audio.play().catch(e => speakNative(text));
            return;
        }
        speakNative(text);
    }

    function speakNative(text) {
        if(!window.speechSynthesis) return;
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(text);
        if(config.googleSettings) {
            u.pitch = config.googleSettings.pitch || 1;
            u.rate = config.googleSettings.rate || 1;
            const voices = window.speechSynthesis.getVoices();
            const v = voices.find(x => x.lang.includes(config.googleSettings.lang));
            if(v) u.voice = v;
        }
        window.speechSynthesis.speak(u);
    }

    // --- 3D ENGINE ---
    let scene, camera, renderer, weapon;
    let particles = [], balloons = [], mobs = [];
    let score = 0;
    
    // Physics & Controls
    const move = { f:0, b:0, l:0, r:0, j:0, s:0 };
    const player = { pos: new THREE.Vector3(0,2,0), vel: new THREE.Vector3(), onGround: false };
    let yaw = 0, pitch = 0;
    
    // Procedural Textures
    function getTex(c, type) {
        const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
        const ctx = cvs.getContext('2d');
        ctx.fillStyle = c; ctx.fillRect(0,0,64,64);
        for(let i=0;i<200;i++) {
            ctx.fillStyle = `rgba(0,0,0,${Math.random()*0.2})`;
            ctx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
        }
        // Mob Face
        if(type === 'face') {
            ctx.fillStyle = '#222'; 
            ctx.fillRect(10, 20, 10, 10); ctx.fillRect(44, 20, 10, 10); // Eyes
            ctx.fillRect(20, 45, 24, 6); // Mouth
        }
        const t = new THREE.CanvasTexture(cvs); t.magFilter = THREE.NearestFilter;
        return t;
    }

    function init3D() {
        scene = new THREE.Scene(); 
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 80);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const amb = new THREE.AmbientLight(0xffffff, 0.6); scene.add(amb);
        const sun = new THREE.DirectionalLight(0xffffff, 0.6);
        sun.position.set(50, 100, 50); sun.castShadow = true;
        sun.shadow.mapSize.width = 1024; sun.shadow.mapSize.height = 1024;
        scene.add(sun);

        createWorld();
        createWeapon();
        spawnBalloons();
        spawnMobs(10); // <--- MOBS ARE BACK!
        createSkyBanner(config.skyText);

        document.addEventListener('keydown', e => k(e.code, 1));
        document.addEventListener('keyup', e => k(e.code, 0));
        document.addEventListener('mousemove', e => {
            if(document.pointerLockElement) {
                yaw -= e.movementX * 0.002;
                pitch -= e.movementY * 0.002;
                pitch = Math.max(-1.5, Math.min(1.5, pitch));
                camera.rotation.set(pitch, yaw, 0, 'YXZ');
            }
        });
        document.addEventListener('mousedown', fire);
        document.body.addEventListener('click', () => {
             if(document.getElementById('card').style.display === 'none') document.body.requestPointerLock();
        });

        animate();
    }

    function k(code, v) {
        if(code==='KeyW') move.f=v; if(code==='KeyS') move.b=v;
        if(code==='KeyA') move.l=v; if(code==='KeyD') move.r=v;
        if(code==='Space') move.j=v; if(code==='ShiftLeft') move.s=v;
    }

    function createWorld() {
        const g = new THREE.PlaneGeometry(200, 200);
        const m = new THREE.MeshLambertMaterial({ map: getTex('#5da34b') });
        m.map.repeat.set(50,50); m.map.wrapS=m.map.wrapT=THREE.RepeatWrapping;
        const floor = new THREE.Mesh(g, m);
        floor.rotation.x = -Math.PI/2; floor.receiveShadow = true;
        scene.add(floor);

        for(let i=0; i<40; i++) {
            const tree = new THREE.Group();
            const t = new THREE.Mesh(new THREE.BoxGeometry(1, 4, 1), new THREE.MeshLambertMaterial({ map: getTex('#5c4033') })); t.position.y=2; t.castShadow=true;
            const l = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), new THREE.MeshLambertMaterial({ map: getTex('#2d5a27') })); l.position.y=5; l.castShadow=true;
            tree.add(t, l);
            tree.position.set(Math.random()*160-80, 0, Math.random()*160-80);
            scene.add(tree);
        }
    }

    function spawnMobs(count) {
        for(let i=0; i<count; i++) {
            const mob = new THREE.Group();
            const isZombie = Math.random()>0.5;
            const color = isZombie ? '#69a859' : '#ddd';
            const cloth = isZombie ? '#3344cc' : '#aaa';
            
            // Body parts
            const matSkin = new THREE.MeshLambertMaterial({ map: getTex(color) });
            const matCloth = new THREE.MeshLambertMaterial({ map: getTex(cloth) });
            const matFace = new THREE.MeshLambertMaterial({ map: getTex(color, 'face') });

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.3), matCloth); body.position.y=1.1;
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), [matSkin, matSkin, matSkin, matSkin, matFace, matSkin]); head.position.y=1.75;
            
            const legGeo = new THREE.BoxGeometry(0.2, 0.7, 0.2);
            const lLeg = new THREE.Mesh(legGeo, matCloth); lLeg.position.set(-0.15, 0.35, 0);
            const rLeg = new THREE.Mesh(legGeo, matCloth); rLeg.position.set(0.15, 0.35, 0);
            
            const armGeo = new THREE.BoxGeometry(0.2, 0.7, 0.2);
            const lArm = new THREE.Mesh(armGeo, matSkin); lArm.position.set(-0.45, 1.3, 0);
            const rArm = new THREE.Mesh(armGeo, matSkin); rArm.position.set(0.45, 1.3, 0);
            
            // PARTY HAT
            const hat = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.5, 16), new THREE.MeshLambertMaterial({color: Math.random()*0xffffff}));
            hat.position.y = 2.1; hat.rotation.x = -0.2;

            mob.add(body, head, lLeg, rLeg, lArm, rArm, hat);
            mob.position.set(Math.random()*60-30, 0, Math.random()*60-30);
            
            mob.userData = { 
                type: 'mob', 
                parts: { lLeg, rLeg, lArm, rArm }, 
                walkTime: Math.random()*100,
                speed: 0.03 + Math.random()*0.02
            };
            
            mobs.push(mob);
            scene.add(mob);
        }
    }

    function createSkyBanner(txt) {
        const cvs = document.createElement('canvas'); cvs.width=1024; cvs.height=256;
        const ctx = cvs.getContext('2d');
        const isAsian = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/.test(txt);
        ctx.font = isAsian ? 'bold 80px sans-serif' : 'bold 80px "VT323", monospace';
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillText(txt, 517, 133);
        ctx.fillStyle='#fff'; ctx.fillText(txt, 512, 128);
        const map = new THREE.CanvasTexture(cvs);
        const banner = new THREE.Mesh(new THREE.PlaneGeometry(50, 12), new THREE.MeshBasicMaterial({map:map, transparent:true, side:2}));
        banner.position.set(0, 30, -50); banner.lookAt(0,0,0);
        scene.add(banner);
    }

    function createWeapon() {
        weapon = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 1), new THREE.MeshLambertMaterial({color: 0x333}));
        body.position.set(0.5, -0.5, -1);
        weapon.add(body);
        scene.add(weapon);
    }

    function spawnBalloons() {
        balloons.forEach(b => scene.remove(b)); balloons=[];
        const texts = config.balloons && config.balloons.length ? config.balloons : ["!"];
        texts.forEach((t, i) => {
            const grp = new THREE.Group();
            const mat = new THREE.MeshPhongMaterial({color: Math.random()*0xffffff, specular: 0x111111, shininess: 50});
            const b = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 32), mat);
            const str = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,3), new THREE.MeshBasicMaterial({color:0xffffff}));
            str.position.y = -2;
            grp.add(b, str);
            grp.position.set(Math.random()*60-30, 8+Math.random()*5, Math.random()*60-30);
            grp.userData = { text: t, isBalloon: true };
            scene.add(grp);
            balloons.push(grp);
        });
    }

    function fire() {
        if(document.pointerLockElement !== document.body) return;
        weapon.children[0].position.z += 0.2; // Recoil
        const ray = new THREE.Raycaster(); ray.setFromCamera(new THREE.Vector2(0,0), camera);
        const hits = ray.intersectObjects(scene.children, true);
        if(hits.length > 0) {
            let obj = hits[0].object; while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;
            if(obj.userData.isBalloon) {
                pop(obj);
            }
        }
    }

    function pop(obj) {
        const osc = (new (window.AudioContext||window.webkitAudioContext)()).createOscillator();
        osc.connect((new (window.AudioContext||window.webkitAudioContext)()).destination);
        osc.frequency.setValueAtTime(400,0); osc.frequency.exponentialRampToValueAtTime(10, 0.1);
        osc.start(); osc.stop(0.1);
        spawnParticles(obj.position, 0xffff00);
        speak(obj.userData.text);
        showCard(obj.userData.text);
        scene.remove(obj);
        balloons = balloons.filter(b => b!==obj);
        score+=100; document.getElementById('score').innerText = score;
        if(balloons.length === 0) setTimeout(spawnBalloons, 3000);
    }

    function spawnParticles(pos, col, isHeart) {
        for(let i=0; i<10; i++) {
            let p;
            if(isHeart) {
                 p = new THREE.Sprite(new THREE.SpriteMaterial({map: heartTex}));
                 p.scale.set(0.8,0.8,1);
            } else {
                 p = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,0.3), new THREE.MeshBasicMaterial({color:col}));
            }
            p.position.copy(pos);
            particles.push({m:p, v:new THREE.Vector3((Math.random()-.5), Math.random(), (Math.random()-.5))});
            scene.add(p);
        }
    }

    function showCard(msg) {
        document.getElementById('card-msg').innerText = msg;
        document.getElementById('card').style.display = 'block';
        document.exitPointerLock();
    }
    window.closeCard = function() {
        document.getElementById('card').style.display = 'none';
        document.body.requestPointerLock();
    };

    function animate() {
        requestAnimationFrame(animate);
        const dt = 0.016;
        
        // Player Physics
        const dir = new THREE.Vector3();
        const fwd = new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(0,yaw,0));
        const right = new THREE.Vector3(1,0,0).applyEuler(new THREE.Euler(0,yaw,0));
        if(move.f) dir.add(fwd); if(move.b) dir.sub(fwd);
        if(move.r) dir.add(right); if(move.l) dir.sub(right);
        if(dir.length()>0) dir.normalize().multiplyScalar(10 * dt);
        player.vel.x = dir.x * 10; player.vel.z = dir.z * 10;
        if(player.onGround && move.j) { player.vel.y = 10; player.onGround = false; }
        player.vel.y -= 20 * dt;
        player.pos.addScaledVector(player.vel, dt);
        if(player.pos.y < 2) { player.pos.y = 2; player.vel.y = 0; player.onGround = true; }
        camera.position.copy(player.pos);
        camera.rotation.set(pitch, yaw, 0, 'YXZ');

        // Mobs Logic
        mobs.forEach(m => {
            const dist = m.position.distanceTo(player.pos);
            const parts = m.userData.parts;
            m.userData.walkTime += dt * 5;
            
            if(dist < 3) {
                // Love Mode
                m.lookAt(player.pos.x, 0, player.pos.z);
                // "Kiss"
                if(Math.random() < 0.02) spawnParticles(m.position.clone().add(new THREE.Vector3(0,2,0)), 0xff0000, true);
                // Stop walking legs
                parts.lLeg.rotation.x = 0; parts.rLeg.rotation.x = 0;
            } else {
                // Random Walk
                m.translateZ(m.userData.speed);
                m.rotation.y += Math.sin(Date.now()*0.001 + m.position.x)*0.02;
                // Animate Legs
                parts.lLeg.rotation.x = Math.sin(m.userData.walkTime);
                parts.rLeg.rotation.x = -Math.sin(m.userData.walkTime);
                parts.lArm.rotation.x = -Math.sin(m.userData.walkTime);
                parts.rArm.rotation.x = Math.sin(m.userData.walkTime);
            }
        });

        // Weapon Sway
        weapon.position.copy(camera.position); weapon.quaternion.copy(camera.quaternion);
        weapon.translateY(Math.sin(Date.now()*0.005)*0.02 - 0.5); 
        weapon.translateZ(Math.cos(Date.now()*0.005)*0.01 - 0.5);
        weapon.translateX(0.5);
        if(weapon.children[0].position.z > -1) weapon.children[0].position.z -= 0.05;

        // Particles
        particles.forEach((p, i) => {
            p.m.position.addScaledVector(p.v, 0.2);
            p.v.y += 0.02; // Hearts float up
            p.m.scale.multiplyScalar(0.95);
            if(p.m.scale.x < 0.01) { scene.remove(p.m); particles.splice(i, 1); }
        });

        // Balloons bob
        balloons.forEach(b => b.position.y += Math.sin(Date.now()*0.002 + b.position.x)*0.01);
        renderer.render(scene, camera);
    }
    
    start();
</script>
</body>
</html>
